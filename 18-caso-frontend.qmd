# Caso 3 — Proyecto Frontend

Aplicación HILL-SE en entornos TypeScript/React

Este caso práctico muestra la aplicación del marco HILL-SE a un proyecto **frontend desarrollado con TypeScript y React**, empleando Vite como entorno de build y Jest + Testing Library para las pruebas.\
El objetivo es ilustrar cómo los principios de *Human-in-the-Loop Software Engineering* pueden aplicarse también al desarrollo de interfaces, asegurando trazabilidad, calidad de código y control humano sobre las contribuciones asistidas por LLMs.

------------------------------------------------------------------------

## Requisitos

### Descripción general

Se desarrollará una **interfaz web** que consuma la API REST del microservicio PCOP (caso 2) y permita: 1. Cargar una instancia de problema PCOP desde un formulario o archivo.\
2. Ejecutar la resolución a través del endpoint `/solve`.\
3. Mostrar los resultados (ruta, beneficio y tiempo de ejecución) en una tabla interactiva.

### Historia de usuario principal

> **Como** usuario técnico,\
> **quiero** resolver y visualizar instancias PCOP desde una interfaz web,\
> **para** interactuar de forma simple con la librería de optimización sin usar código.

### Criterios de aceptación (AC)

``` gherkin
Scenario: Resolver una instancia PCOP desde la interfaz
  Given un formulario con nodos, beneficios y presupuesto
  When el usuario hace clic en “Resolver”
  Then la aplicación envía la instancia a la API REST
  And muestra la ruta óptima, el beneficio total y el tiempo de ejecución
```

### Requisitos no funcionales

| Categoría              | Descripción                   | Umbral      |
|------------------------|-------------------------------|-------------|
| **Rendimiento**        | Renderizado inicial \< 2 s    | ≤ 2 s       |
| **Accesibilidad**      | Cumplir WCAG 2.1 nivel AA     | Obligatorio |
| **Calidad de código**  | ESLint + Prettier sin errores | 100 %       |
| **Cobertura de tests** | Cobertura mínima global       | ≥ 85 %      |

## Diseño

### ADR-003 — Arquitectura React modular

``` makefile
Date: 2025-03-10
Status: Accepted

Contexto:
Se requiere una interfaz desacoplada del backend, componible y mantenible.
Debe integrarse fácilmente con CI/CD y pruebas unitarias.

Decisión:
Adoptar arquitectura React basada en componentes funcionales con hooks,
separando vistas, lógica y servicios API.

Consecuencias:
- Alta testabilidad y facilidad de refactorización.
- Soporte para despliegue estático (Netlify / Vercel).
- Compatibilidad con TypeScript y ESLint.
```

### Diagrama UML (versión 1)

```{mermaid}
classDiagram
    class App {
        +useState()
        +useEffect()
        +render()
    }

    class FormPCOP {
        +onSubmit()
        +validateInput()
    }

    class ResultsTable {
        +render(results)
    }

    class ApiClient {
        +solvePCOP(payload): Promise<Response>
    }

    App --> FormPCOP
    App --> ResultsTable
    App --> ApiClient
```

## Implementación

### Estructura del proyecto

``` txt
frontend/
 ├── src/
 │   ├── components/
 │   │   ├── FormPCOP.tsx
 │   │   └── ResultsTable.tsx
 │   ├── services/
 │   │   └── apiClient.ts
 │   ├── App.tsx
 │   ├── main.tsx
 │   └── types.ts
 ├── tests/
 │   ├── FormPCOP.test.tsx
 │   └── ResultsTable.test.tsx
 ├── vite.config.ts
 ├── package.json
 └── tsconfig.json
```

### Código base

``` tsx
// src/services/apiClient.tsx
export interface PCOPRequest {
  nodes: number[];
  distances: number[][];
  benefits: number[];
  penalties: number[];
  budget: number;
  method: string;
}

export interface PCOPResponse {
  route: number[];
  objective_value: number;
  runtime: number;
}

export async function solvePCOP(payload: PCOPRequest): Promise<PCOPResponse> {
  const response = await fetch("http://localhost:8000/solve/", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  if (!response.ok) throw new Error("Error al resolver el problema.");
  return response.json();
}
```

``` tsx
// src/components/FormPCOP.tsx
import React, { useState } from "react";
import { solvePCOP, PCOPRequest } from "../services/apiClient";

export const FormPCOP: React.FC<{ onResult: (data: any) => void }> = ({ onResult }) => {
  const [nodes, setNodes] = useState("0,1,2");
  const [budget, setBudget] = useState("40");

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    const payload: PCOPRequest = {
      nodes: nodes.split(",").map(Number),
      distances: [[0,10,15],[10,0,20],[15,20,0]],
      benefits: [10,5,8],
      penalties: [0,3,1],
      budget: parseFloat(budget),
      method: "greedy"
    };
    const result = await solvePCOP(payload);
    onResult(result);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>Nodos: <input value={nodes} onChange={e => setNodes(e.target.value)} /></label>
      <label>Presupuesto: <input value={budget} onChange={e => setBudget(e.target.value)} /></label>
      <button type="submit">Resolver</button>
    </form>
  );
};
```

``` tsx
// src/components/ResultsTable.tsx
import React from "react";

export const ResultsTable: React.FC<{ result: any }> = ({ result }) => (
  <table>
  <thead><tr><th>Ruta</th><th>Beneficio</th><th>Tiempo (s)</th></tr></thead>
  <tbody>
    <tr>
      <td>{result?.route?.join(" → ")}</td>
      <td>{result?.objective_value.toFixed(2)}</td>
      <td>{result?.runtime.toFixed(2)}</td>
    </tr>
  </tbody>
</table>
);
```

``` tsx
// src/App.tsx
import React, { useState } from "react";
import { FormPCOP } from "./components/FormPCOP";
import { ResultsTable } from "./components/ResultsTable";

export const App: React.FC = () => {
  const [result, setResult] = useState<any>(null);
  return (
    <div>
      <h1>PCOP Solver UI</h1>
      <FormPCOP onResult={setResult} />
      {result && <ResultsTable result={result} />}
    </div>
  );
};
```

## Validación

### Tests de interfaz

``` tsx
// tests/FormPCOP.test.tsx
import { render, screen, fireEvent } from "@testing-library/react";
import { FormPCOP } from "../src/components/FormPCOP";

test("renderiza formulario y captura nodos", async () => {
  const mockHandler = jest.fn();
  render(<FormPCOP onResult={mockHandler} />);
  const input = screen.getByLabelText(/Nodos/i);
  fireEvent.change(input, { target: { value: "0,1" } });
  expect((input as HTMLInputElement).value).toBe("0,1");
});
```

``` tsx
// tests/ResultsTable.test.tsx
import { render, screen } from "@testing-library/react";
import { ResultsTable } from "../src/components/ResultsTable";

test("muestra resultados correctamente", () => {
  const result = { route: [0,1,2], objective_value: 23.5, runtime: 1.3 };
  render(<ResultsTable result={result} />);
  expect(screen.getByText("0 → 1 → 2")).toBeInTheDocument();
  expect(screen.getByText("23.50")).toBeInTheDocument();
});
```

## Pipeline CI/CD

### GitHub Actions

``` yaml
name: frontend_ci

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Install dependencies
        run: npm ci
      - name: Lint
        run: npm run lint
      - name: Run tests
        run: npm test -- --coverage
      - name: Build
        run: npm run build
```

### Quality Gates

-   **ESLint:** sin errores ni advertencias.

-   **Prettier:** formato automático al guardar.

-   **Coverage threshold:** ≥ 85 % con Jest.

-   **Accessibility tests:** validados con `axe-core`.

## Resultados

| Métrica              | Valor         | Umbral  |
|----------------------|---------------|---------|
| Cobertura            | 88 %          | ≥ 85 %  |
| Build                | 100 % exitoso | 100 %   |
| Tiempo de build      | 1.2 min       | ≤ 2 min |
| Vulnerabilidades npm | 0             | 0       |

## Conclusión

El caso frontend demuestra que HILL-SE puede aplicarse con eficacia en **entornos JavaScript/TypeScript modernos**, combinando:

-   Principios de ingeniería de software (UML, ADRs, tests)

-   Control de calidad automático y CI/CD

-   Supervisión humana de código generado o asistido

La trazabilidad, los quality gates y la gobernanza técnica mantienen el mismo nivel de rigor que en backend o librerías Python, consolidando el enfoque HILL-SE como un **paradigma integral de desarrollo asistido por IA**.